hashAnswer$nicc <- hashAnswer$nicc %>% as.factor()
hashAnswer$fsfat <- hashAnswer$fsfat/10
hashAnswer$fsvfatu <- hashAnswer$fsvfatu/10
hashTest2 <- hashAnswer %>% group_by(studentId) %>% mutate("count" = n()) %>%
filter(count > 7 & fsfat < 10)
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
#Lykkja til að setja saman gagnasafnið, ýtrar fyrir hvern fyrirlestur og finnur jafnmarga nemendur aftur
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
#smá fall til að reikna BrierScoreið
BrierScore <- function(modl, df ) {
predicted <- predict(modl, type = "response")
truth <- df$correct
return(mean((predicted-truth)^2))
}
modl22 <- function(df) {
ans <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = df, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
return(ans)
}
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
ormodel <- Funmod(df)
original <- data.frame(brier = BrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
test2 <- Bootwork(hashTest2, 3, modl22)
end_time <- Sys.time()
end_time - start_time
install.packages("funModeling")
#sma skoda
library(funModeling)
df_status(hashAnswer)
freq(hashAnswer, input = 'hsta')
load("Data/ans22")
load("Data/ans42")
summary(ans42)
summary(ans22)
SBrierScore <- function(modl, df) {
predicted <- predict(modl, type = "response")
truth <- df$correct
Bs <- mean((predicted-truth)^2)
Bmax <- mean(predict(modl, type = "response")) * (1-mean(predict(modl, type = "response")))
return(1 - Bs/Bmax)
}
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
ormodel <- Funmod(df)
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
test2 <- Bootwork(hashTest2, 3, modl22)
SBrierScore(ans22, hashTest2)
start_time <- Sys.time()
test2 <- Bootwork(hashTest2, 3, modl22)
end_time <- Sys.time()
end_time - start_time
#Teikningar gagnasett
dfmean <- hashAnswer %>% group_by(fsfat, hsta, lectureId) %>% filter(fsfat <=50) %>%
summarise("med"=mean(correct),"fjold"=n_distinct(studentId))
#Teikningar gagnasett
dfmean <- hashAnswer %>% group_by(fsfat, hsta, lectureId) %>% filter(fsfat <50) %>%
summarise("med"=mean(correct),"fjold"=n_distinct(studentId))
dfmean %>% ggplot(aes(x = fsfat, color = hsta)) +
geom_histogram()
dfmean %>% ggplot(aes(x = fsfat, fill = hsta)) +
geom_histogram(position = "dodge")
dfmean %>% ggplot(aes(x = fsfat, fill = hsta)) +
geom_histogram(position = "dodge2")
dfmean %>% ggplot(aes(x = fsfat, fill = hsta)) +
geom_histogram(position = "dodge2")
dfmean %>% ggplot(aes(x = fsfat, fill = hsta)) +
geom_histogram(position = "dodge3")
?grid.arrange
#Teikningar gagnasett
dfmean <- hashAnswer %>% group_by(fsfat, hsta, lectureId) %>% filter(fsfat <50) %>%
summarise("med"=mean(correct))
for (lId in dfmean$lectureId) {
#filtering out for this lecture
dftemp <- dfmean %>% filter(lectureId == lId)
#drawing the cool graph
p1t <- dftemp %>%
ggplot(aes(x = fsfat, y = med, color = hsta))+
geom_point() +
geom_smooth()
#Drawing the histogram
p2t <- dftemp %>% ggplot(aes(x = fsfat, fill = hsta)) +
geom_histogram(position = "dodge2")
#combining the 2
pcom <- grid.arrange(p1t, p2t, nrow = 1, top = paste0('fyrirlestur ', lId))
ggsave(paste0('Img/lecmean', lId, '.png'), pcom, width = 20, height = 10)
}
unique(dfmean$lectureId)
dfmean %>% ggplot(aes(x = fsfat, fill = hsta)) +
geom_histogram(position = "dodge2", binwidth = 1)
dfmean %>% ggplot(aes(x = fsfat, fill = hsta)) +
geom_histogram(position = "dodge2", binwidth = 1)
dfmean %>% ggplot(aes(x = fsfat, fill = hsta)) +
geom_histogram(position = "dodge2", binwidth = 2)
#Teikningar gagnasett
dfmean <- hashAnswer %>% group_by(fsfat, hsta, lectureId) %>% filter(fsfat <50) %>%
summarise("med"=mean(correct))
hashAnswer <- read.csv('Data/hashAnswer4.csv')
hashAnswer <- hashAnswer %>% subset(select=-c(X))
hashAnswer$hsta <- hashAnswer$hsta%>%as.character()
hashAnswer$lectureId <- hashAnswer$lectureId %>% as.factor()
hashAnswer$studentId <- hashAnswer$studentId %>% as.factor()
#Teikningar gagnasett
dfmean <- hashAnswer %>% group_by(fsfat, hsta, lectureId) %>% filter(fsfat <50) %>%
summarise("med"=mean(correct))
dfmean %>% ggplot(aes(x = fsfat, fill = hsta)) +
geom_histogram(position = "dodge2", binwidth = 1)
#Teikningar gagnasett
dfmean <- hashAnswer %>% group_by(fsfat, hsta, lectureId) %>% filter(fsfat <50) %>%
summarise("med"=mean(correct), "fjoldi" = n())
dfmean %>% filter(lectureId == "3082") %>%
ggplot() +
geom_bar(aes(x = fsfat, y = fjoldi))
dfmean %>% filter(lectureId == "3082") %>%
ggplot() +
geom_bar(aes(x = fsfat, y = fjoldi), stat = "identidy")
dfmean %>% filter(lectureId == "3082") %>%
ggplot() +
geom_bar(aes(x = fsfat, y = fjoldi), stat = "identity")
dfmean %>% filter(lectureId == "3082") %>%
ggplot() +
geom_bar(aes(x = fsfat, y = fjoldi, fill = hsta), stat = "identity")
dfmean %>% filter(lectureId == "3082") %>%
ggplot() +
geom_bar(aes(x = fsfat, y = fjoldi, fill = hsta), stat = "identity", position = "dodge2")
dfmean %>% filter(lectureId == "3082") %>%
ggplot() +
geom_histogram(aes(x = fsfat, y = fjoldi, fill = hsta), stat = "identity", position = "dodge2")
dfmean %>% filter(lectureId == "3082") %>%
ggplot() +
geom_histogram(aes(x = fsfat, y = fjoldi, fill = hsta), stat = "identity", position = "dodge2", show.legend = F)
for (lId in unique(dfmean$lectureId)) {
#filtering out for this lecture
dftemp <- dfmean %>% filter(lectureId == lId)
#drawing the cool graph
p1t <- dftemp %>%
ggplot(aes(x = fsfat, y = med, color = hsta))+
geom_point(show.legend = F) +
geom_smooth(show.legend = F)
#Drawing the histogram
p2t <- dftemp %>% ggplot(aes(x = fsfat, y = fjoldi, fill = hsta)) +
geom_bar(stat = "identity", position = "dodge2", show.legend = F)
#combining the 2
pcom <- grid.arrange(p1t, p2t, nrow = 1, top = paste0('fyrirlestur ', lId))
ggsave(paste0('Img/lecmean', lId, '.png'), pcom, width = 20, height = 10)
}
ranef(ans22)
emmeans::emmeans(ans22, ~ fsfat, type = "response")
emmeans::emmeans(ans22, type = "response")
emmeans::emmeans(ans22, ~fsfat*hsta, type = "response")
emmeans::emmeans(ans22, ~fsfat*hsta + nicc + gpow + lectureId, type = "response")
tmp <-emmeans::emmeans(ans22, ~fsfat*hsta + nicc + gpow + lectureId, type = "response")
View(tmp)
summary(tmp)
hashTest2 %>% group_by(fsfat) %>% summarise(count = n()) %>%
ggplot(aes(x = fsfat, y = count)) +
geom_line()
ranef(ans22)
ranef(ans22)
tmp <- ranef(ans22)
tmp <- ranef(ans22) %>% as.data.frame()
tmp %>%
ggplot(aes(x = grp, y = condval)) +
geom_bar(stat = "identity")
sample(1:5, replace = TRUE)
sample(1:25, replace = TRUE)
test2 <- as.data.frame(x = NULL, y = NULL, z = NULL)
for (i in 1:100){
test2 <- rbind(test2, c(i, 2 * i, 3 * i))
}
test1 <- bootcreate(hashTest2)
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
#Lykkja til að setja saman gagnasafnið, ýtrar fyrir hvern fyrirlestur og finnur jafnmarga nemendur aftur
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
nb <- dftemp$studentId %>% n()
if (ni != nb){
print("wait a minute")
}
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
test1 <- bootcreate(hashTest2)
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
#Lykkja til að setja saman gagnasafnið, ýtrar fyrir hvern fyrirlestur og finnur jafnmarga nemendur aftur
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
nbi <- dftemp$studentId %>% n()
print(paste0("fyrst kemur ", ni, "svo kemur", nbi))
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
test1 <- bootcreate(hashTest2)
?n()
?count
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
#Lykkja til að setja saman gagnasafnið, ýtrar fyrir hvern fyrirlestur og finnur jafnmarga nemendur aftur
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
nbi <- dftemp$studentId %>% length()
print(paste0("fyrst kemur ", ni, "svo kemur", nbi))
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
test1 <- bootcreate(hashTest2)
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
#Lykkja til að setja saman gagnasafnið, ýtrar fyrir hvern fyrirlestur og finnur jafnmarga nemendur aftur
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
nb <- dftemp$studentId %>% length()
if (ni != nb){
print("wait a minute")
}
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
test1 <- bootcreate(hashTest2)
hashAnswer <- read.csv('Data/hashAnswer4.csv')
hashAnswer <- hashAnswer %>% subset(select=-c(X))
hashAnswer$hsta <- hashAnswer$hsta%>%as.character()
hashAnswer$lectureId <- hashAnswer$lectureId %>% as.factor()
hashAnswer$studentId <- hashAnswer$studentId %>% as.factor()
hashAnswer$nicc <- hashAnswer$nicc %>% as.factor()
hashAnswer$fsfat <- hashAnswer$fsfat/10
hashAnswer$fsvfatu <- hashAnswer$fsvfatu/10
#model sem notuð eru fyrir bootwork
modl42 <- function(df) {
ans <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId), family = binomial(link = "logit"),
data = df, nAGQ = 0, control=glmerControl(optimizer="nloptwrap",optCtrl=list(maxfun=2e5)))
return(ans)
}
modl22 <- function(df) {
ans <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = df, nAGQ = 0, control=glmerControl(optimizer="nloptwrap",optCtrl=list(maxfun=2e5)))
return(ans)
}
hashTest2 <- hashAnswer %>% group_by(studentId) %>% mutate("count" = n()) %>%
filter(count > 7 & fsfat < 10)
#Fyrst eru það þægilegu dplyr og tidyr föllin. Svo RMySQL til að fá aðgang á SQL
library(dbplyr)
library(dplyr)
library(RMySQL)
library(tidyr)
#Hvað gerir MASS aftur?
library(MASS)
#GGplot gott til að teikna
library(ggplot2)
library(gridExtra)
#Tidyverse er geðveikt
library(tidyverse)
#modelr var fyrir %$% skipanir minnist mig
library(modelr)
#hvað gerir rlang aftur?
library(rlang)
#lme4 og lmerTest er fyrir glmer og fleira þægilegt
library(lme4)
library(lmerTest)
#Car er til að geta notað Anova
library(car)
#cAIC4 er svo það sé hægt að prufa stepcAIC, svo stepAIC fyrir glmer fallið, mun líklega ekki nota, tekur of langan tíma
library(cAIC4)
#til að geta gert trapz fyrir AUC í ROC
library(pracma)
#Bootstrapping pakki
library(boot)
#Fyrir AUC reikninga
library(cvAUC)
hashTest2 <- hashAnswer %>% group_by(studentId) %>% mutate("count" = n()) %>%
filter(count > 7 & fsfat < 10)
hashAnswer <- read.csv('Data/hashAnswer4.csv')
hashAnswer <- hashAnswer %>% subset(select=-c(X))
hashAnswer$hsta <- hashAnswer$hsta%>%as.character()
hashAnswer$lectureId <- hashAnswer$lectureId %>% as.factor()
hashAnswer$studentId <- hashAnswer$studentId %>% as.factor()
hashAnswer$nicc <- hashAnswer$nicc %>% as.factor()
hashAnswer$fsfat <- hashAnswer$fsfat/10
hashAnswer$fsvfatu <- hashAnswer$fsvfatu/10
hashTest2 <- hashAnswer %>% group_by(studentId) %>% mutate("count" = n()) %>%
filter(count > 7 & fsfat < 10)
fit <- modl22(hashTest2)
summary(fit)
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
#Lykkja til að setja saman gagnasafnið, ýtrar fyrir hvern fyrirlestur og finnur jafnmarga nemendur aftur
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
#smá fall til að reikna BrierScoreið
BrierScore <- function(modl, df ) {
predicted <- predict(modl, type = "response")
truth <- df$correct
return(mean((predicted-truth)^2))
}
SBrierScore <- function(modl, df) {
predicted <- predict(modl, type = "response")
truth <- df$correct
Bs <- mean((predicted-truth)^2)
Bmax <- mean(predict(modl, type = "response")) * (1-mean(predict(modl, type = "response")))
return(1 - Bs/Bmax)
}
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
ormodel <- Funmod(df)
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
test2 <- Bootwork(hashTest2, 10, modl22)
end_time <- Sys.time()
end_time - start_time
load("Data/ans22")
summary(fit)
summary(ans22)
broom::tidy(fit)
broom::tidy(ans22)
BrierScore(fit, hashTest2)
BrierScore(ans22, hashTest2)
AUC(predict(fit, type = "response"), hashTest2$correct)
AUC(predict(ans22, type = "response"), hashTest2$correct)
start_time <- Sys.time()
fit2 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = df, control=glmerControl(optimizer="nloptwrap",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
fit2 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = hashTest2, control=glmerControl(optimizer="nloptwrap",optCtrl=list(maxfun=2e5)))
start_time <- Sys.time()
fit2 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = hashTest2, control=glmerControl(optimizer="nloptwrap",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
broom::tidy(fit2)
broom::tidy(fit)
start_time <- Sys.time()
fit3 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = hashTest2, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
start_time <- Sys.time()
fit3 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = hashTest2, nAGQ = 0, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
broom::tidy(fit3)
broom::tidy(ans22)
summary(ans22)
start_time <- Sys.time()
ans22 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = hashTest2, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
options(contrasts = c("contr.sum", "contr.poly"))
start_time <- Sys.time()
fit3 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = hashTest2, nAGQ = 0, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
broom::tidy(fit3)
broom::tidy(ans22)
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
options(contrasts = c("contr.sum", "contr.poly"))
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
ormodel <- Funmod(df)
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
#Time difference of 28.67935 mins
fit1 <- glmer(correct ~ fsfat * hsta + nicc + gpow + lectureId + (1 | studentId),
family = binomial(link = "logit"), data = hashTest2, nAGQ = 0,
control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
#here we go again
library(RCurl)
library(dfoptim)
library(nloptr)
library(optimx)
afurl <- "https://raw.githubusercontent.com/lme4/lme4/master/misc/issues/allFit.R"
eval(parse(text=getURL(afurl)))
aa2 <- allFit(fit1)
is.OK <- sapply(aa2,is,"merMod")  ## nlopt NELDERMEAD failed, others succeeded
aa2.OK <- aa2[is.OK]
lapply(aa2.OK,function(x) x@optinfo$conv$lme4$messages)
install.packages('tinytex')
install.packages("tinytex")
tinytex::install_tinytex()
