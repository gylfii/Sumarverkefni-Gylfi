BrierScore(predict(ans22, type = "response"), hashTest2$correct)
BrierScore(ans42, hashTest2)
BrierScore <- function(modl, df ) {
predicted <- predict(modl, type = "response")
truth <- df$correct
return(mean((predicted-truth)^2))
}
BrierScore(ans42, hashTest2)
BrierScore(ans22, hashTest2)
?boot
install.packages("boot")
#Fyrst eru það þægilegu dplyr og tidyr föllin. Svo RMySQL til að fá aðgang á SQL
library(dbplyr)
library(dplyr)
library(RMySQL)
library(tidyr)
#Hvað gerir MASS aftur?
library(MASS)
#GGplot gott til að teikna
library(ggplot2)
library(gridExtra)
#Tidyverse er geðveikt
library(tidyverse)
#modelr var fyrir %$% skipanir minnist mig
library(modelr)
#hvað gerir rlang aftur?
library(rlang)
#lme4 og lmerTest er fyrir glmer og fleira þægilegt
library(lme4)
library(lmerTest)
#Car er til að geta notað Anova
library(car)
#cAIC4 er svo það sé hægt að prufa stepcAIC, svo stepAIC fyrir glmer fallið, mun líklega ekki nota, tekur of langan tíma
library(cAIC4)
#til að geta gert trapz fyrir AUC í ROC
library(pracma)
#Bootstrapping pakki
library(boot)
#Bootstrapping pakki
library(boot)
#Bootstrapping pakki
library(boot)
#Fyrst eru það þægilegu dplyr og tidyr föllin. Svo RMySQL til að fá aðgang á SQL
library(dbplyr)
library(dplyr)
library(RMySQL)
library(tidyr)
#Hvað gerir MASS aftur?
library(MASS)
#GGplot gott til að teikna
library(ggplot2)
library(gridExtra)
#Tidyverse er geðveikt
library(tidyverse)
#modelr var fyrir %$% skipanir minnist mig
library(modelr)
#hvað gerir rlang aftur?
library(rlang)
#lme4 og lmerTest er fyrir glmer og fleira þægilegt
library(lme4)
library(lmerTest)
#Car er til að geta notað Anova
library(car)
#cAIC4 er svo það sé hægt að prufa stepcAIC, svo stepAIC fyrir glmer fallið, mun líklega ekki nota, tekur of langan tíma
library(cAIC4)
#til að geta gert trapz fyrir AUC í ROC
library(pracma)
test2 <- sample(test1, 5, replace = TRUE)
test1 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
test2 <- sample(test1, 5, replace = TRUE)
testf <- test1[test2]
test1 <- 1:10 * 3
test2 <- sample(1:10, 5, replace = TRUE)
testf <- test1[test2]
hashAnswer <- read.csv('Data/hashAnswer4.csv')
hashAnswer <- hashAnswer %>% subset(select=-c(X))
hashAnswer$hsta <- hashAnswer$hsta%>%as.character()
hashAnswer$lectureId <- hashAnswer$lectureId %>% as.factor()
hashAnswer$studentId <- hashAnswer$studentId %>% as.factor()
hashAnswer$nicc <- hashAnswer$nicc %>% as.factor()
hashAnswer$fsfat <- hashAnswer$fsfat/10
hashAnswer$fsvfatu <- hashAnswer$fsvfatu/10
nesttest1 <- hashAnswer %>% group_by(lectureId) %>% nest()
View(nesttest1)
nesttest1 <- hashAnswer %>% group_by(lectureId, studentId) %>% nest()
nesttest2 <- nesttest1[[test2]]
nesttest2 <- nesttest1[[test2,]]
nesttest2 <- nesttest1[[test2],]
nesttest2 <- nesttest1[[2]]
nesttest2 <- nesttest1[[3]]
nesttest2 <- nesttest1[1,]
nesttest2 <- nesttest1[1, ] %>% unnest()
nesttest2 <- nesttest1[1, ] %>% unnest(cols = c(data))
nesttest2 <- nesttest1[c(1, 2), ] %>% unnest(cols = c(data))
nesttest3 <- nesttest1[c(4, 5), ] %>% unnest(cols = c(data))
nesttest4 <- rbind(nesttest2, nesttest3)
?bootMer
load("Data/ans42")
testing <- bootMer(ans42, mean, nsim = 2)
load("Data/ans22")
blankfunc <- function(.){
sigma(.)
}
testing <- bootMer(ans22, mean, nsim = 2)
blankfunc <- function(.){
sigma(.)
}
testing <- bootMer(ans22, blankfunc, nsim = 2)
nesttest5 <- rbind(NULL, nesttest4)
(nesttest1 %>% filter(lectureId == 3082) %$% n_distinct(studentId))
justtest <- nesttest1 %>% filter(lectureId == 3082)
justtest$studentId %>% n_distinct()
justtest %>% n()
justtest$studentId %>% n()
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
test1 <- bootcreate(hashAnswer)
hashAnswer %>% group_by(lectureId) %>% summarise(n_distinct(studentId))
test1 %>% filter(fsfat == 0) %>% group_by(lectureId) %>% summarise(n())
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
print(paste0(id, ": ", ni))
}
return(bootmade)
}
test1 <- bootcreate(hashAnswer)
hashAnswer %>% group_by(lectureId) %>% summarise(n_distinct(studentId))
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
test2 <- NULL
test2 <- NULL
for(i in 1:100){
test2[i] <- i
}
test2 <- NULL
test2 <- NULL
for (i in 1:100){
test2[i] <- c(i, 2 * i, 3 * i)
}
warnings()
test2 <- NULL
for (i in 1:100){
test2[i] <- list(i, 2 * i, 3 * i)
}
list(1, 2, 3)
test2 <- as.data.frame(x = NULL, y = NULL, z = NULL)
for (i in 1:100){
test2[i, ] <- c(i, 2 * i, 3 * i)
}
warnings()
test2 <- as.data.frame(x = NULL, y = NULL, z = NULL)
for (i in 1:100){
test2 <- rbind(test2, c(i, 2 * i, 3 * i))
}
#smá fall til að reikna BrierScoreið
BrierScore <- function(modl, df ) {
predicted <- predict(modl, type = "response")
truth <- df$correct
return(mean((predicted-truth)^2))
}
install.packages("ROCR")
#Fyrir AUC reikninga
library(ROCR)
install.packages("cvAUC")
#Fyrir AUC reikninga
library(cvAUC)
hashTest2 <- hashAnswer %>% group_by(studentId) %>% mutate("count" = n()) %>%
filter(count > 7 & fsfat < 10)
test1 <- data.frame(brier = BrierScore(ans42, hashTest2),
AUC = AUC(predict(ans42, type = "response"), hashTest2$correct))
View(test1)
hashTest2 <- hashAnswer %>% group_by(studentId) %>% mutate("count" = n()) %>%
filter(count > 7 & fsfat < 10)
hashAnswer <- read.csv('Data/hashAnswer4.csv')
hashAnswer <- hashAnswer %>% subset(select=-c(X))
hashAnswer$hsta <- hashAnswer$hsta%>%as.character()
hashAnswer$lectureId <- hashAnswer$lectureId %>% as.factor()
hashAnswer$studentId <- hashAnswer$studentId %>% as.factor()
hashAnswer$nicc <- hashAnswer$nicc %>% as.factor()
hashAnswer$fsfat <- hashAnswer$fsfat/10
hashAnswer$fsvfatu <- hashAnswer$fsvfatu/10
hashTest2 <- hashAnswer %>% group_by(studentId) %>% mutate("count" = n()) %>%
filter(count > 7 & fsfat < 10)
start_time <- Sys.time()
ans42 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId), family = binomial(link = "logit"), data = hashTest2, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
start_time <- Sys.time()
ans42 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId), family = binomial(link = "logit"), data = hashTest2, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
ormodel <- Funmod(df)
original <- data.frame(brier = BrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
#model sem notuð eru fyrir bootwork
modl42 <- function(df) {
glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId), family = binomial(link = "logit"),
data = df, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
}
#model sem notuð eru fyrir bootwork
modl42 <- function(df) {
ans <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId), family = binomial(link = "logit"),
data = df, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
return(ans)
}
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
#Lykkja til að setja saman gagnasafnið, ýtrar fyrir hvern fyrirlestur og finnur jafnmarga nemendur aftur
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
#smá fall til að reikna BrierScoreið
BrierScore <- function(modl, df ) {
predicted <- predict(modl, type = "response")
truth <- df$correct
return(mean((predicted-truth)^2))
}
#model sem notuð eru fyrir bootwork
modl42 <- function(df) {
ans <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId), family = binomial(link = "logit"),
data = df, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
return(ans)
}
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
ormodel <- Funmod(df)
original <- data.frame(brier = BrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
end_time - start_time
start_time <- Sys.time()
Bootwork(hashTest2, 3, modl42())
end_time <- Sys.time()
end_time - start_time
Bootwork(hashTest2, 3, modl42)
start_time <- Sys.time()
test1 <- Bootwork(hashTest2, 3, modl42)
end_time <- Sys.time()
end_time - start_time
save(test1, file ="Data/test1")
#Fyrst eru það þægilegu dplyr og tidyr föllin. Svo RMySQL til að fá aðgang á SQL
library(dbplyr)
library(dplyr)
library(RMySQL)
library(tidyr)
#Hvað gerir MASS aftur?
library(MASS)
#GGplot gott til að teikna
library(ggplot2)
library(gridExtra)
#Tidyverse er geðveikt
library(tidyverse)
#modelr var fyrir %$% skipanir minnist mig
library(modelr)
#hvað gerir rlang aftur?
library(rlang)
#lme4 og lmerTest er fyrir glmer og fleira þægilegt
library(lme4)
library(lmerTest)
#Car er til að geta notað Anova
library(car)
#cAIC4 er svo það sé hægt að prufa stepcAIC, svo stepAIC fyrir glmer fallið, mun líklega ekki nota, tekur of langan tíma
library(cAIC4)
#til að geta gert trapz fyrir AUC í ROC
library(pracma)
hashAnswer <- read.csv('Data/hashAnswer4.csv')
hashAnswer <- hashAnswer %>% subset(select=-c(X))
hashAnswer$hsta <- hashAnswer$hsta%>%as.character()
hashAnswer$lectureId <- hashAnswer$lectureId %>% as.factor()
hashAnswer$studentId <- hashAnswer$studentId %>% as.factor()
hashAnswer$nicc <- hashAnswer$nicc %>% as.factor()
hashAnswer$fsfat <- hashAnswer$fsfat/10
hashAnswer$fsvfatu <- hashAnswer$fsvfatu/10
hashTest2 <- hashAnswer %>% group_by(studentId) %>% mutate("count" = n()) %>%
filter(count > 7 & fsfat < 10)
start_time <- Sys.time()
#Time difference of 28.67935 mins
fit1 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"), data = hashTest2)
end_time <- Sys.time()
end_time - start_time
tt <- getME(fit1, "theta")
ll <- getME(fit1, "lower")
min(tt[ll == 0])
?allFit
afurl <- "https://raw.githubusercontent.com/lme4/lme4/master/misc/issues/allFit.R"
eval(parse(text=getURL(afurl)))
install.packages("RCurl")
#here we go again
library(Rcurl)
#here we go again
library(RCurl)
eval(parse(text=getURL(afurl)))
install.packages("optimx")
install.packages("nloptr")
install.packages("dfoptim")
library(dfoptim)
library(nloptr)
library(optimx)
aa <- allFit(fit1)
is.OK <- sapply(aa,is,"merMod")  ## nlopt NELDERMEAD failed, others succeeded
aa.OK <- aa[is.OK]
lapply(aa.OK,function(x) x@optinfo$conv$lme4$messages)
summary(aa$nmkbw)
lapply(aa.OK, summary)
lapply(aa.OK,function(x) x@optinfo$conv$lme4$messages)
#Time difference of 28.67935 mins
fit1 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId),
family = binomial(link = "logit"), data = hashTest2)
aa2 <- allFit(fit1)
load("Data/ans42")
aa2 <- allFit(ans42)
save(aa, "Data/aa1")
save(aa, file = "Data/aa1")
save(aa2, file = "Data/aa2")
is.OK <- sapply(aa2,is,"merMod")  ## nlopt NELDERMEAD failed, others succeeded
aa2.OK <- aa2[is.OK]
lapply(aa2.OK,function(x) x@optinfo$conv$lme4$messages)
start_time <- Sys.time()
#Time difference of 28.67935 mins
fit2 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId),
family = binomial(link = "logit"), data = hashTest2,
control=glmerControl(optimizer="nlminbwrap",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
start_time <- Sys.time()
#Time difference of 28.67935 mins
fit2 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId),
family = binomial(link = "logit"), data = hashTest2,
control=glmerControl(optimizer="nloptwrap.NLOPT_LN_NELDERMEAD",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
start_time <- Sys.time()
#Time difference of 28.67935 mins
fit1 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId),
family = binomial(link = "logit"), data = hashTest2,
control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
#Teiknum ROC
ROCDraw <- function(df, modl) {
score <- predict(modl, type = "response")
y <- df$correct
#False positive rate
FPR <- 0
#true positive rate
TPR <- 0
#setjum upp threshold
threshold <- seq(from = 0, to = 1, by = 0.01)
# number of positive and negative
P <- sum(y)
N <- length(y) - P
#Iterate through all thresholds
for (j in 1:length(threshold)) {
FP <- 0
TP <- 0
thresh <- threshold[j]
for (i in 1:length(score)) {
if (score[i] >= thresh) {
if (y[i] == 1){
TP <- TP + 1
}
if (y[i] == 0){
FP <- FP + 1
}
}
}
FPR[j] <- FP/N
TPR[j] <- TP/P
}
#Reiknum AUC með trapezoid reglunni
auc <- -1 * trapz(FPR, TPR)
#Að lokum teiknum við aðeins upp
p <- data.frame(x = FPR, y = TPR) %>%
ggplot(aes(x = FPR, y = TPR)) +
geom_area(fill = "lightblue")+
geom_line(color = "orange", size = 1.5) +
geom_line(data = data.frame(x = seq(0, 1, 0.01), y = seq(0, 1, 0.01)), aes(x = x, y = y), linetype = "dashed") +
labs(title = paste0("ROC curve, AUC = ", round(auc, digits = 4))) +
xlab("False Positive Rate") +
ylab("True Positive Rate") +
coord_cartesian(xlim = c(0, 1), ylim = c(0, 1))
return(p)
}
p1 <- ROCDraw(hashTest2, ans42)
p1
BrierScore <- function(modl, df ) {
predicted <- predict(modl, type = "response")
truth <- df$correct
return(mean((predicted-truth)^2))
}
BrierScore(ans42, hashTest2)
BrierScore(ans22, hashTest2)
load("Data/ans22")
BrierScore(ans22, hashTest2)
start_time <- Sys.time()
#Time difference of 28.67935 mins
fit3 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId),
family = binomial(link = "logit"), data = hashTest2,
control=glmerControl(optimizer="nloptwrap",optCtrl=list(algorithm = "NLOPT_LN_NELDERMEAD", maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
start_time <- Sys.time()
#Time difference of 28.67935 mins
fit3 <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 + fsfat * hsta | studentId),
family = binomial(link = "logit"), data = hashTest2,
control=glmerControl(optimizer="nloptwrap",optCtrl=list(algorithm = "NLOPT_LN_NELDERMEAD", maxfun=2e5)))
end_time <- Sys.time()
end_time - start_time
summary(ans42)
hashTest2 %>% ungroup() %>% mutate(pred = predict(ans42, type = "response")) %>%
filter(hsta == "0" & lectureId == "3082") %>%
ggplot(aes(x = fsvfatu, y = correct, group = studentId), ) +
geom_point() +
geom_line(aes(y = pred)) +
theme(legend.position = "none")
Anova(ans22, type = 3)
summary(ans22)
is.OK <- sapply(aa,is,"merMod")  ## nlopt NELDERMEAD failed, others succeeded
aa.OK <- aa[is.OK]
lapply(aa.OK,function(x) x@optinfo$conv$lme4$messages)
library(rmdformats)
#knitr::opts_chunk$set(echo = TRUE)
source('Script/Settings.R')
hashAnswer <- read.csv('Data/hashAnswer4.csv') %>% subset(select = -c(fsvfat, fsvfatu, X))
hashAnswer$hsta <- hashAnswer$hsta%>%as.character()
hashAnswer$lectureId <- hashAnswer$lectureId %>% as.factor()
hashAnswer$studentId <- hashAnswer$studentId %>% as.factor()
hashAnswer$nicc <- hashAnswer$nicc %>% as.factor()
hashAnswer %>% glimpse()
hashAnswer <- read.csv('Data/hashAnswer4.csv') %>% subset(select = -c(timeStart, fsvfat, fsvfatu, X))
hashAnswer$hsta <- hashAnswer$hsta%>%as.character()
hashAnswer$lectureId <- hashAnswer$lectureId %>% as.factor()
hashAnswer$studentId <- hashAnswer$studentId %>% as.factor()
hashAnswer$nicc <- hashAnswer$nicc %>% as.factor()
hashAnswer %>% glimpse()
