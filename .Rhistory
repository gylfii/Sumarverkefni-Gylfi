}
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
options(contrasts = c("contr.sum", "contr.poly"))
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
ormodel <- Funmod(df)
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
BootedData <- Bootwork(hashTest2, 200, modl22)
end_time <- Sys.time()
end_time - start_time
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
options(contrasts = c("contr.sum", "contr.poly"))
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
ormodel <- Funmod(df)
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
print(i)
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
BootedData <- Bootwork(hashTest2, 200, modl22)
end_time <- Sys.time()
end_time - start_time
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
options(contrasts = c("contr.sum", "contr.poly"))
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
print('hey')
ormodel <- Funmod(df)
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
print(i)
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
BootedData <- Bootwork(hashTest2, 200, modl22)
end_time <- Sys.time()
end_time - start_time
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
options(contrasts = c("contr.sum", "contr.poly"))
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
print('hey')
ormodel <- Funmod(df)
print('another hey')
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
print('consider this hey')
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
print(i)
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
BootedData <- Bootwork(hashTest2, 200, modl22)
end_time <- Sys.time()
end_time - start_time
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
options(contrasts = c("contr.sum", "contr.poly"))
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
print('hey')
ormodel <- Funmod(df)
print('another hey')
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
print('consider this hey')
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
print(i)
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
BootedData <- Bootwork(hashTest2, 200, modl22)
end_time <- Sys.time()
end_time - start_time
wait <- modl22(hashTest2)
options(contrasts = c("contr.sum", "contr.poly"))
wait <- modl22(hashTest2)
modl22 <- function(df) {
options(contrasts = c("contr.sum", "contr.poly"))
ans <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = df, nAGQ = 0, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
print("check")
return(ans)
}
wait <- modl22(hashTest2)
modl22 <- function(df) {
ans <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = df, nAGQ = 0, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
return(ans)
}
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
print('hey')
ormodel <- Funmod(df)
print('another hey')
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
print('consider this hey')
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
print(i)
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
test2 <- Bootwork(hashTest2, 10, modl22)
end_time <- Sys.time()
end_time - start_time
#Fyrst eru það þægilegu dplyr og tidyr föllin. Svo RMySQL til að fá aðgang á SQL
library(dbplyr)
library(dplyr)
library(RMySQL)
library(tidyr)
#Hvað gerir MASS aftur?
library(MASS)
#GGplot gott til að teikna
library(ggplot2)
library(gridExtra)
#Tidyverse er geðveikt
library(tidyverse)
#modelr var fyrir %$% skipanir minnist mig
library(modelr)
#hvað gerir rlang aftur?
library(rlang)
#lme4 og lmerTest er fyrir glmer og fleira þægilegt
library(lme4)
library(lmerTest)
#Car er til að geta notað Anova
library(car)
#cAIC4 er svo það sé hægt að prufa stepcAIC, svo stepAIC fyrir glmer fallið, mun líklega ekki nota, tekur of langan tíma
library(cAIC4)
#til að geta gert trapz fyrir AUC í ROC
library(pracma)
#Bootstrapping pakki
library(boot)
#Fyrir AUC reikninga
library(cvAUC)
hashAnswer <- read.csv('Data/hashAnswer4.csv')
hashAnswer <- hashAnswer %>% subset(select=-c(X))
hashAnswer$hsta <- hashAnswer$hsta%>%as.character()
hashAnswer$lectureId <- hashAnswer$lectureId %>% as.factor()
hashAnswer$studentId <- hashAnswer$studentId %>% as.factor()
hashAnswer$nicc <- hashAnswer$nicc %>% as.factor()
hashAnswer$fsfat <- hashAnswer$fsfat/10
hashAnswer$fsvfatu <- hashAnswer$fsvfatu/10
hashTest2 <- hashAnswer %>% group_by(studentId) %>% mutate("count" = n()) %>%
filter(count > 7 & fsfat < 10)
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
#Lykkja til að setja saman gagnasafnið, ýtrar fyrir hvern fyrirlestur og finnur jafnmarga nemendur aftur
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
#smá fall til að reikna BrierScoreið
BrierScore <- function(modl, df ) {
predicted <- predict(modl, type = "response")
truth <- df$correct
return(mean((predicted-truth)^2))
}
SBrierScore <- function(modl, df) {
predicted <- predict(modl, type = "response")
truth <- df$correct
Bs <- mean((predicted-truth)^2)
Bmax <- mean(predict(modl, type = "response")) * (1-mean(predict(modl, type = "response")))
return(1 - Bs/Bmax)
}
modl22 <- function(df) {
ans <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = df, nAGQ = 0, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
return(ans)
}
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
print('hey')
ormodel <- Funmod(df)
print('another hey')
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
print('consider this hey')
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
print(i)
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
BootedData <- Bootwork(hashTest2, 200, modl22)
end_time <- Sys.time()
end_time - start_time
neghashes<-read.csv("Data/bigNegHash.wide.txt",sep=" ", na.strings = ".")
neghashes<-read.csv("Data/bigNegHash.txt",sep=" ", na.strings = ".")
View(neghashes)
#hashes<-read.csv("Data/bighashfile.txt",sep=" ",col.names = c("dir","qName","hash","numQ","notaType"))
hashes<-read.csv("Data/bighashfile.wide.txt",sep=" ",col.names = c("dir","qName","hash","hash2","hash3","numQ","notaType"),na.strings = ".")
View(hashes)
View(neghashes)
#Fyrst eru það þægilegu dplyr og tidyr föllin. Svo RMySQL til að fá aðgang á SQL
library(dbplyr)
library(dplyr)
library(RMySQL)
library(tidyr)
#Hvað gerir MASS aftur?
library(MASS)
#GGplot gott til að teikna
library(ggplot2)
library(gridExtra)
#Tidyverse er geðveikt
library(tidyverse)
#modelr var fyrir %$% skipanir minnist mig
library(modelr)
#hvað gerir rlang aftur?
library(rlang)
#lme4 og lmerTest er fyrir glmer og fleira þægilegt
library(lme4)
library(lmerTest)
#Car er til að geta notað Anova
library(car)
#cAIC4 er svo það sé hægt að prufa stepcAIC, svo stepAIC fyrir glmer fallið, mun líklega ekki nota, tekur of langan tíma
library(cAIC4)
#til að geta gert trapz fyrir AUC í ROC
library(pracma)
#Bootstrapping pakki
library(boot)
#Fyrir AUC reikninga
library(cvAUC)
hashAnswer <- read.csv('Data/hashAnswer4.csv')
hashAnswer <- hashAnswer %>% subset(select=-c(X))
hashAnswer$hsta <- hashAnswer$hsta%>%as.character()
hashAnswer$lectureId <- hashAnswer$lectureId %>% as.factor()
hashAnswer$studentId <- hashAnswer$studentId %>% as.factor()
hashAnswer$nicc <- hashAnswer$nicc %>% as.factor()
hashAnswer$fsfat <- hashAnswer$fsfat/10
hashAnswer$fsvfatu <- hashAnswer$fsvfatu/10
hashTest2 <- hashAnswer %>% group_by(studentId) %>% mutate("count" = n()) %>%
filter(count > 7 & fsfat < 10)
#þetta er fall sem er að búa til nýtt bootstrapped gagnasafn til að geta keyrt restina í
bootcreate <- function(df) {
#Búið til nested gagnasafn til að geta tekið fyrir hvern nemenda
dfnest <- df %>% group_by(lectureId, studentId) %>% nest()
bootmade <- NULL
#Lykkja til að setja saman gagnasafnið, ýtrar fyrir hvern fyrirlestur og finnur jafnmarga nemendur aftur
for (id in unique(dfnest$lectureId)) {
dftemp <- dfnest %>% filter(lectureId == id)
ni <- dftemp$studentId %>% n_distinct()
takenNr <- sample(1:ni, replace = TRUE)
notnest <- dftemp[takenNr, ] %>% unnest(cols = c(data))
bootmade <- rbind(bootmade, notnest)
}
return(bootmade)
}
#smá fall til að reikna BrierScoreið
BrierScore <- function(modl, df ) {
predicted <- predict(modl, type = "response")
truth <- df$correct
return(mean((predicted-truth)^2))
}
SBrierScore <- function(modl, df) {
predicted <- predict(modl, type = "response")
truth <- df$correct
Bs <- mean((predicted-truth)^2)
Bmax <- mean(predict(modl, type = "response")) * (1-mean(predict(modl, type = "response")))
return(1 - Bs/Bmax)
}
modl22 <- function(df) {
ans <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = df, nAGQ = 0, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
return(ans)
}
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
print('hey')
ormodel <- Funmod(df)
print('another hey')
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
print('consider this hey')
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
print(i)
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
BootedData <- Bootwork(hashTest2, 200, modl22)
end_time <- Sys.time()
end_time - start_time
neghashes<-read.csv("Data/bigNegHash.txt",sep=" ", na.strings = ".")
View(neghashes)
neghashes<-read.csv("Data/bigNegHash.txt",sep=" ", na.strings = ".")
View(neghashes)
start_time <- Sys.time()
BootedData <- Bootwork(hashTest2, 200, modl22)
end_time <- Sys.time()
end_time - start_time
modl22 <- function(df) {
ans <- glmer(correct ~ fsfat*hsta + nicc + gpow + lectureId + (1 | studentId), family = binomial(link = "logit"),
data = df, nAGQ = 0, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
return(ans)
}
rm(hashAnswer)
rm(neghashes)
#Bootwork er svo aðal Bootstrap fallið
Bootwork <- function(df, iteration, Funmod){
#Byrjum fyrst að keyra það fyrir upprunalega gagnasafnið
print('hey')
ormodel <- Funmod(df)
print('another hey')
original <- data.frame(brier = BrierScore(ormodel, df),
StanBrier = SBrierScore(ormodel, df),
AUC = AUC(predict(ormodel, type = "response"), df$correct))
print('consider this hey')
#Bý til nýjann grunn til að safna saman efnið frá bootstrappinu
bootel <- data.frame(brier = numeric(0), AUC = numeric(0))
for (i in 1:iteration){
print(i)
#Bý til nýtt safn með bootstrap
Bdf <- bootcreate(df)
#Bý til model fyrir þetta bootstrap
Bmodel <- Funmod(Bdf)
#Reiknað breyturnar sem það þarf að reikna
Nadditions <- data.frame(brier = BrierScore(Bmodel, Bdf),
StanBrier = SBrierScore(Bmodel, Bdf),
AUC = AUC(predict(Bmodel, type = "response"), Bdf$correct))
#Geyma efnið í gagnasafninu
bootel <- rbind(bootel, Nadditions)
}
#skila original og bootel
return(list(original, bootel))
}
start_time <- Sys.time()
BootedData <- Bootwork(hashTest2, 200, modl22)
end_time <- Sys.time()
end_time - start_time
?memory.limit
memory.size()
memory.size(max = T)
memory.limit(100000)
start_time <- Sys.time()
BootedData <- Bootwork(hashTest2, 200, modl22)
end_time <- Sys.time()
end_time - start_time
save(BootedData, file = "Data/BootedData")
load('Data/BootedData')
library(dbplyr)
library(dplyr)
library(RMySQL)
library(tidyr)
library(MASS)
library(ggplot2)
library(magrittr)
library(lubridate)
#les inn öll gögninn, nota mestalagi bara answer gagnasafnið
twDb<-src_mysql("tw_quizdb", host = "127.0.0.1", port = 3306, user = "gss24", password = "JuwofKWT2Ewc")
answer<-tbl(twDb,"answer")
question<-tbl(twDb,"question")
lectureStudentSetting<-tbl(twDb,"lectureStudentSetting")
#hashes<-read.csv("Data/bighashfile.txt",sep=" ",col.names = c("dir","qName","hash","numQ","notaType"))
hashes<-read.csv("Data/bighashfile.wide.txt",sep=" ",col.names = c("dir","qName","hash","hash2","hash3","numQ","notaType"),na.strings = ".")
#pathQ<-unique(paste(hashes$dir,hashes$qName,sep=""))
plonePath<-unique(paste(hashes$dir,hashes$qName,sep=""))
plonePath<-as.data.frame(plonePath)
hashes$plonePath<-paste(hashes$dir,hashes$qName,sep="")
left_join(plonePath,as.data.frame(question))->myQuestions
#question%>%filter(plonePath%in%pathQ)->myQuestions
#myQuestions<-as.data.frame(myQuestions)
answer%>%filter(timeStart>"2020-01-01 00:01:01")->answerRed
answerRed<-as.data.frame(answerRed)
# view(answerRed)
studentgpow <- lectureStudentSetting %>% as.data.frame() %>% filter(key == "iaa_adaptive_gpow" & creationDate > "2020-01-01 00:01:01") %>%
dplyr::select(lectureId, studentId, lectureVersion, value, creationDate)
inner_join(answerRed,myQuestions) -> myAnswer
MyAnswer<-as.data.frame(myAnswer)
explory <- left_join(MyAnswer, studentgpow)
MyAnswer$gpow <- ifelse(is.na(explory$value), 0.25, explory$value)
MyAnswer %>% summarise(n())
MyAnswer %>% summarise(n(), n_distinct(studentId))
neghashes<-read.csv("Data/bigNegHash.txt",sep=" ", na.strings = ".")
View(neghashes)
